//! This is a Telegram Bot for use mainly in group chats, that will parse all messages in the chat
//! (excluding messages from other bots or to other bots) and detect and convert units of measurement.
//! For example when discussing the weather someone might use Fahrenheit, and the bot will return the
//! converted value in Celsius, or vice versa, meaning that neither the person wishing to simply tell
//! people what their weather is like, nor the people who wish to understand it, needs to look up the
//! converted value themselves. The bot can be found at
//! [`@auto_convert_bot`](https://t.me/auto_convert_bot) on Telegram.
//!
//! The crate root currently holds the definition of the default
//! [`ChatSettings`](struct.ChatSettings.html), as well as the
//! basic type structure necessary to make these settings possible; the AutoConvertBot struct
//! itself, which interfaces between the Telegram Api and the Postgresql Database; and of course
//! the actual parsing function.
//!
//! The easiest way of implementing your own conversions is to add them to the definition of the Map
//! in [`ChatSettings::default()`](struct.ChatSettings#default.html), although of course one unit
//! may only map to one unit at a time.
//! To See your changes in action, either give me a Pull Request, make a Fork and start it as your
//! own bot using [`@BotFather`](https://t.me/BotFather) on Telegram.

pub mod models;
/// Database schema macros generated by [`diesel`](http://docs.diesel.rs/diesel/index.html).
pub mod schema;

use std::collections::{BTreeMap, HashMap, HashSet};
use std::env;
use std::fmt;
use sublime_fuzzy::ScoreConfig;
use telegram_bot::*;

#[macro_use]
extern crate diesel;
extern crate uuid;
use diesel::pg::PgConnection;
use diesel::prelude::*;
use diesel::{insert_into, RunQueryDsl};
use dotenv::dotenv;

use crate::models::{
    FetchedChatSettings, FetchedDefinedNames, FetchedDictionary, FetchedLongHands,
};
use schema::{chatsettings, definednames, dictionary, longhands};
use std::cmp::Ordering;
use std::hash::{Hash, Hasher};
use std::str::SplitWhitespace;
use uuid::Uuid;

/// The bot struct which provides measurement detection functionality and works as an interface
/// between the Telegram Bot API and the Database.
///
/// The instance of this struct is to contain all interaction with the database, the parsing,
/// detection and conversion logic, and serves as the container for the
/// [`telegram_bot::Api`](../telegram_bot/api/struct.Api.html).
pub struct AutoConvertBot {
    /// the [`telegram_bot::Api`](../telegram_bot/api/struct.Api.html)
    /// endpoint.
    pub api: Api,
    /// A
    /// [`HashMap`](https://doc.rust-lang.org/nightly/std/collections/hash/map/struct.HashMap.html)
    /// serving as a simple cache mapping
    /// [`ChatId`](../telegram_bot_raw/types/refs/struct.ChatId.html) to
    /// [`ChatSettings`](struct.ChatSettings.html).
    pub chat_map: HashMap<ChatId, ChatSettings>,
    /// The connection to the database.
    pub conn: PgConnection,
}

impl AutoConvertBot {
    /// Bot Init and Constructor.
    ///
    /// ## panics
    /// Requires the following environment variables to be set:
    ///  - `TELEGRAM_BOT_TOKEN`
    ///  - `DATABASE_HOST`
    ///  - `DATABASE_PORT`
    ///  - `DATABASE_USER`
    ///  - `DATABASE_PASS`
    ///  - `DATABASE_DB`
    ///
    /// everything except `TELEGRAM_BOT_TOKEN` may be set in the `.env` file, the token is SECRET!
    /// Exposing the bot token would give anyone permission to run any code over `@auto_convert_bot`
    pub fn bot_setup() -> Self {
        dotenv().ok();

        let database_host = env::var("DATABASE_HOST").expect("DATABASE_HOST must be set");
        let database_port = env::var("DATABASE_PORT").expect("DATABASE_PORT must be set");
        let database_user = env::var("DATABASE_USER").expect("DATABASE_USER must be set");
        let database_pass = env::var("DATABASE_PASS").expect("DATABASE_PASSWORD must be set");
        let database_db = env::var("DATABASE_DB").expect("DATABASE_DB must be set");

        let database_url = format!("postgres://{}:{}@{}:{}/{}", database_user, database_pass, database_host, database_port, database_db);
        let conn = PgConnection::establish(&database_url)
            .expect(&format!("Error connecting to {}", database_url));

        let token = env::var("TELEGRAM_BOT_TOKEN").expect("TELEGRAM_BOT_TOKEN not set");
        let api = Api::new(token);
        let chat_map = HashMap::<ChatId, ChatSettings>::new();
        Self {
            api,
            chat_map,
            conn,
        }
    }

    /// Register a new chat with its own settings.
    ///
    /// Should only be called when the chat did not already exist, but checks for existence
    /// of the chat using the `chat_id`.
    ///
    /// # Errors
    /// Throws a
    /// [`ParseIntError`](https://doc.rust-lang.org/nightly/core/num/struct.ParseIntError.html) if
    /// `chat_id` as a [`String](https://doc.rust-lang.org/nightly/alloc/string/struct.String.html)
    /// could not be parsed as an integer.
    ///
    /// throws a [`diesel::result::Error`](../diesel/result/enum.Error.html) if: an error occurred
    /// during insertion in one of the tables, if an error occurred during fetch of newly inserted
    /// definednames entries, if the fetched definednames entries contained a
    /// [`Unit`](struct.Unit.html`) value not contained in the
    /// [`ChatSetting`](struct.ChatSettings.html)s (at all), or if one of the target (value) units
    /// was not found in the fetched definednames.
    pub fn register_chat(&mut self, chat_id: &ChatId) -> Result<(), ConvertBotError> {
        if !self.chat_map.contains_key(chat_id) {
            let id = chat_id
                .to_string()
                .parse::<Integer>()
                .map_err(ConvertBotError::ParseIntError)?;
            // vvv Err expected as normal control flow.
            if let Err(diesel::result::Error::NotFound) = self.fetch_chat_settings(id) {
                let default_settings = ChatSettings::default();
                self.chat_map.insert(chat_id.clone(), default_settings);
                let bigint_id = chat_id.to_string().as_str().parse::<Integer>()
                    .map_err(ConvertBotError::ParseIntError)?;
                self.insert_chat_db(bigint_id, ChatSettings::default())
                    .map_err(ConvertBotError::DieselError)?;
            } // else chat already existed and is now fetched
        }
        Ok(())
    }

    /// Inserts an entire [`ChatSettings`](struct.ChatSettings.html) into the database.
    ///
    /// This needs to happen if the chat is newly registered or perhaps if the (planned)
    /// `/restore_defaults` command was called.
    ///
    /// # Errors
    /// throws a [`diesel::result::Error`](../diesel/result/enum.Error.html) if: an error occurred
    /// during insertion in one of the tables, if an error occurred during fetch of newly inserted
    /// definednames entries, if the fetched definednames entries contained a
    /// [`Unit`](struct.Unit.html`) value not contained in the
    /// [`ChatSetting`](struct.ChatSettings.html)s (at all), or if one of the target (value) units
    /// was not found in the fetched definednames.
    fn insert_chat_db(
        &self,
        chat_id: Integer,
        chat_settings: crate::ChatSettings,
    ) -> Result<(), diesel::result::Error> {
        let chat_settings_entry =
            models::NewChatSettings::new(chat_id.clone(), chat_settings.whole_message_always);
        insert_into(chatsettings::dsl::chatsettings)
            .values(chat_settings_entry)
            .execute(&self.conn)?;
        for unit in &chat_settings.unit_set {
            let defined_names_entry =
                models::NewDefinedNames::new(chat_id, unit.short_hand.clone());
            let id: Uuid = insert_into(definednames::dsl::definednames)
                .values(defined_names_entry)
                .returning(definednames::name_id)
                .get_result(&self.conn)?;
            for long_hand in &unit.long_hands {
                let long_hands_entry = models::NewLongHands::new(id, long_hand.to_owned());
                insert_into(longhands::dsl::longhands)
                    .values(long_hands_entry)
                    .execute(&self.conn)?;
            }
        }
        // Insert all the entries in the dictionary using a query for the UUID's
        // Iterating over definednames rows using get for dictionary.
        let these_defined_names: Vec<FetchedDefinedNames> = definednames::table
            .filter(definednames::chat_id.eq(chat_id))
            .load::<FetchedDefinedNames>(&self.conn)?;
        for defined_name in &these_defined_names {
            let source_id = defined_name.name_id;
            let short_hand =
                get_from_set(defined_name.short_hand.as_str(), &chat_settings.unit_set);
            if let Some(u) = short_hand {
                let target_unit = chat_settings.dictionary.get(&u);
                if let Some((target, conversion_rate)) = target_unit {
                    let maybe_target_def_name = these_defined_names
                        .iter()
                        .find(|&z| z.short_hand == target.short_hand);
                    // Possible change in control flow due to unsuccessful insert attempts
                    if let Some(target_def_name) = maybe_target_def_name {
                        let dictionary_entry = models::NewDictionary::new(
                            source_id,
                            target_def_name.name_id,
                            *conversion_rate,
                        );
                        insert_into(dictionary::dsl::dictionary)
                            .values(dictionary_entry)
                            .execute(&self.conn)?;
                    } else {
                        eprintln!(
                            "Error getting target from DefinedNames while inserting\
                        Dictionary"
                        );
                        return Err(diesel::result::Error::NotFound);
                    }
                } else {
                    println!(
                        "Warning: getting target from dictionary while inserting Dictionary \
                        Failed"
                    );
                    // This can actually not be an error, some types might map to nothing
                }
            } else {
                eprintln!("Error while fetching DefinedNames for inserting Dictionary.");
                return Err(diesel::result::Error::NotFound);
            }
        }
        Ok(())
    }

    /// Detects measurements in a
    /// [`String`](https://doc.rust-lang.org/nightly/alloc/string/struct.String.html) and converts
    /// them in the same loop for the sake of efficiency.
    ///
    /// # Example
    /// ```
    /// use auto_convert_bot::AutoConvertBot;
    /// use telegram_bot::ChatId;
    /// // faking the parameters to mock having received a message from a registered chat
    /// let mut bot = AutoConvertBot::bot_setup();
    /// let chat_id = ChatId::new(1);
    /// let data = "The speed limit is 70 miles per hour".to_owned();
    ///
    /// let converted_units = bot.detect_measurements_and_convert(&chat_id, &data);
    /// ```
    pub fn detect_measurements_and_convert(
        &mut self,
        chat_id: &ChatId,
        data: &String,
    ) -> Vec<AmountUnit> {
        let mut unit_vec: Vec<AmountUnit> = Vec::new();

        let conversion_map = match &self.chat_map.get(chat_id) {
            Some(cs) => (**cs).clone(),
            None => {
                eprintln!("Somehow got in impossible situation, contains was called before this");
                ChatSettings::default()
            }
        };

        // ignore recognized indices by keeping a list of indices recognized.
        let mut recognized_list: Vec<usize> = Vec::new();
        // TODO: make this sorted by longer longnames first: ATTEMPTING BTREEMAP
        // SOMEHOW conversionmap does not contain enough values.
        for (conversion_key, (conversion_value, conversion_rate)) in conversion_map.dictionary {
            // get and convert;
            let temp_vec = conversion_key.recognize(&data.as_str(), &mut recognized_list);
            for temp in temp_vec {
                let new_amount = match conversion_key.short_hand.as_str() {
                    "°F" => (temp.get_amount() + 459.67) * conversion_rate - 273.15,
                    "°C" => (temp.get_amount() + 273.15) * conversion_rate - 459.67,
                    _ => temp.get_amount() * conversion_rate,
                };
                unit_vec.push(AmountUnit::new(conversion_value.clone(), new_amount))
            }
        }

        unit_vec
    }

    /// Fetches and reconstructs the [`ChatSettings`](struct.ChatSettings.html) instance for the
    /// specified chat.
    ///
    /// returns
    /// [`Ok`](https://doc.rust-lang.org/core/result/enum.Result.html#variant.Ok)`(`
    /// [`ChatSettings`](struct.ChatSettings.html)`)` on success. Also adds the
    /// [`ChatSettings`](struct.ChatSettings.html) to the cache on success.
    ///
    /// # Errors
    /// [`Err`](https://doc.rust-lang.org/core/result/enum.Result.html#variant.Err)`(`[`diesel::result::Error::NotFound`](../diesel/result/enum.Error.html#variant.NotFound)`)`
    /// if the specified chat is not in the database.
    pub fn fetch_chat_settings(
        &mut self,
        chat_id: Integer,
    ) -> Result<ChatSettings, diesel::result::Error> {
        //TODO: replace Error with whatever Error my Query returns
        // use inner_join with explicit on to fix error
        let chat_settings: QueryResult<
            Vec<(
                FetchedChatSettings,
                (
                    FetchedDefinedNames,
                    FetchedLongHands,
                    Option<FetchedDictionary>,
                ),
            )>,
        > = chatsettings::table
            .inner_join(
                definednames::table
                    .inner_join(longhands::table.on(definednames::name_id.eq(longhands::name_id)))
                    .left_outer_join(
                        dictionary::table.on(definednames::name_id.eq(dictionary::name_id_source)),
                    ),
            )
            .filter(chatsettings::chat_id.eq(chat_id))
            .load::<(
                FetchedChatSettings,
                (
                    FetchedDefinedNames,
                    FetchedLongHands,
                    Option<FetchedDictionary>,
                ),
            )>(&self.conn);
        // Now we have a Vec with a tuple of the above type
        if let Ok(settings) = chat_settings {
            let mut unit_set: HashSet<Unit> = HashSet::new();
            let mut dictionary: BTreeMap<Unit, (Unit, f64)> = BTreeMap::new();
            let mut sort_names: Vec<(&FetchedDefinedNames, &FetchedLongHands)> =
                settings.iter().map(|(_, (x, y, _))| (x, y)).collect();
            sort_names.sort_by(|(a, _), (b, _)| a.cmp(b));
            let mut prev_name: &str = "";
            // The error is the last item in the iter is not added to unit_set
            let mut long_hands_collector = Vec::new();
            sort_names.iter().for_each(|(x, y)| {
                if !(prev_name == "" || prev_name.eq(x.short_hand.as_str())) {
                    unit_set.insert(Unit::new(prev_name, long_hands_collector.clone()));
                    long_hands_collector = Vec::new();
                }
                prev_name = x.short_hand.as_str();
                long_hands_collector.push(y.long_hand.clone());
            });
            unit_set.insert(Unit::new(prev_name, long_hands_collector));
            // Iterate Dictionary entries after unit_set finished, because target is in some
            // non deterministic location in join.
            settings
                .iter()
                .filter(|(_, (_, _, maybe_dict))| maybe_dict.is_some())
                .map(|(_, (fetched_df, _, dict_entry))| (fetched_df, dict_entry))
                .for_each(|(fetched_df, dict_entry)| {
                    let entry = dict_entry.as_ref().unwrap();
                    // Panics if previous step of collecting definednames was broken.
                    // This failed. i retried. it didn't fail.
                    let source_unit =
                        get_from_set(fetched_df.short_hand.as_str(), &unit_set).unwrap();
                    let target_unit = sort_names
                        .iter()
                        .map(|(z, _)| z)
                        .find(|&z| z.name_id == entry.name_id_target)
                        .unwrap();
                    dictionary.insert(
                        source_unit,
                        (
                            // this failed. i retried. it didn't fail.
                            get_from_set(target_unit.short_hand.as_str(), &unit_set).unwrap(),
                            entry.conversion_rate,
                        ),
                    );
                });
            // unit_set and dictionary populated
            let top_settings = settings
                .iter()
                .map(|(s, (_, _, _))| s)
                .next()
                .ok_or_else(|| diesel::result::Error::NotFound)?;
            let fetched_chat_settings =
                ChatSettings::new(top_settings.whole_message_always, dictionary, unit_set);
            self.chat_map
                .insert(ChatId::new(chat_id), fetched_chat_settings.clone());
            return Ok(fetched_chat_settings);
        }
        Err(diesel::result::Error::NotFound)
    }
}

/// An Error type to compose the different Error types met in this library.
#[derive(Debug)]
pub enum ConvertBotError {
    DieselError(diesel::result::Error),
    ParseIntError(std::num::ParseIntError),
}

/// A [`Unit`](struct.Unit.html) with an `f64` amount attached, for collecting and displaying
/// converted [`Unit`](struct.Unit.html)s.
///
/// The only user facing type.
#[derive(Debug)]
pub struct AmountUnit {
    names: Unit,
    amount: f64,
}

impl AmountUnit {
    /// Constructor taking a [`Unit`](struct.Unit.html) and the amount of it in `f64`.
    pub fn new(names: Unit, amount: f64) -> Self {
        Self { names, amount }
    }

    /// A getter for the amount.
    ///
    /// Amounts are in `f64`.
    pub fn get_amount(&self) -> f64 {
        self.amount
    }
}

impl fmt::Display for AmountUnit {
    /// Display function for sending results to users.
    ///
    /// Displays at 3 decimal places, for user readability.
    fn fmt(&self, f: &mut std::fmt::Formatter) -> fmt::Result {
        write!(f, "{:.3} {}", self.amount, self.names)
    }
}

/// A data abstraction for a [`Unit`]() of measurement, holding the scientific symbol as a shorthand,
/// which is matched for exactly, and a
/// [`Vec`](https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html)`<`
/// [`String`](https://doc.rust-lang.org/nightly/alloc/string/struct.String.html)`>` of long-hands
/// to be matched against with fuzzy logic.
///
/// Needs to be [`Hash`](https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html),
/// [`Eq`](https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html) and
/// [`Ord`](https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html), for use in
/// [`Hash`](https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html) and
/// `BTree` [collections](https://doc.rust-lang.org/std/collections/index.html). See the
/// [`Trait` implemententations](struct.Unit.html#implementations) for more details.
///
/// No further logic contained, no sub types, no From/To between different unit types and their
/// conversion rates, no prefix types/traits etc. in contrast to more object oriented structured
/// approaches to the problem.
#[derive(Clone, Debug)]
pub struct Unit {
    short_hand: String,
    long_hands: Vec<String>,
}

impl Unit {
    /// Constructor.
    fn new(short_hand: &str, long_hands: Vec<String>) -> Self {
        Self {
            short_hand: short_hand.to_owned(),
            long_hands,
        }
    }

    /// Recognizes specific [`Unit`]()s in a string, and returns a
    /// [`Vec](https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html)`<`
    /// [`AmountUnit`](struct.AmountUnit.html)`>`, providing a value was present where detection was
    /// positive.
    ///
    /// needs to allow for multiple of the same [`Unit`]()s to be found at once
    /// therefore using a split_whitespace approach, performing lookaheads for multiword names,
    /// and lookbehinds to check for a numeric value.
    fn recognize(&self, data: &str, recognized_list: &mut Vec<usize>) -> Vec<AmountUnit> {
        let mut unit_vec = Vec::new();
        let white_space: Vec<&str> = data.split_whitespace().collect();
        for (i, word) in white_space.iter().enumerate() {
            if recognized_list.contains(&i) {
                continue;
            }
            // use simpler direct comparison with shorthand first for early continue
            if self.short_hand == *word {
                self.push_to_vec_with_num(&mut unit_vec, &white_space, i);
                recognized_list.push(i);
                continue;
            }
            let long_hand_splits: Vec<SplitWhitespace> = self
                .long_hands
                .iter()
                .map(|s| s.split_whitespace())
                .collect();
            'medium: for split in long_hand_splits {
                // early continue in this loop to avoid recognizing the same word with different
                // long hands
                if recognized_list.contains(&i) {
                    continue;
                }
                // TODO: implement multiword names by iter with lookahead on first match
                let mut full_candidate = "".to_owned();
                for j in 0..(split.clone().count()) {
                    if let Some(str_word) = white_space.get(i + j) {
                        full_candidate += str_word;
                        full_candidate += "_";
                    } else {
                        continue 'medium;
                    }
                }

                let mut s = "".to_owned();
                split.for_each(|splitter| {
                    s += splitter;
                    s += "_";
                });
                let mut search =
                    sublime_fuzzy::FuzzySearch::new(s.as_str(), full_candidate.as_str(), true);
                // adjust config against false positives and low detection
                let config = ScoreConfig::new(8, 72, 64, 4);
                search.set_score_config(config);
                match search.best_match() {
                    Some(m) => {
                        if m.score() >= 300 {
                            recognized_list.push(i);
                            self.push_to_vec_with_num(&mut unit_vec, &white_space, i);
                            break 'medium;
                        }
                    }
                    None => (),
                }
            }
        }

        unit_vec
    }

    /// Helper function that pushes detected [`Unit`]() into `unit_vec` with its `f64` amount if
    /// an amount was found directly before the `Unit`.
    ///
    /// Otherwise, a user just mentioned a unit of
    /// measurement, not a quantified measurement specifically, and these occurrences can be safely
    /// ignored from this point in detection.
    fn push_to_vec_with_num(
        &self,
        unit_vec: &mut Vec<AmountUnit>,
        white_space: &Vec<&str>,
        i: usize,
    ) {
        if i > 0 {
            if let Some(str_num) = white_space.get(i - 1) {
                if let Ok(f) = str_num.parse::<f64>() {
                    unit_vec.push(AmountUnit::new(self.clone(), f))
                }
            }
        }
    }
}

impl PartialEq for Unit {
    /// [`Unit`]() is compared for equality by its scientific symbol, `short_hand`, as this is its
    /// unique identifying aspect.
    fn eq(&self, other: &Self) -> bool {
        self.short_hand == other.short_hand
    }
}

impl Eq for Unit {}

impl Hash for Unit {
    /// [`Hash`](https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html) must be congruous with
    /// [`Eq`](https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html) and
    /// [`PartialEq`](https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html); this not
    /// being the case would constitute a 'logic error' in
    /// [`Hash`](https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html)
    /// [collections](https://doc.rust-lang.org/std/collections/index.html).
    // (and will break `tests::insert_fetch_equality`.)
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.short_hand.hash(state);
    }
}

impl Ord for Unit {
    /// Sort descending based on maximum amount of words in one long_hand in order to ensure
    /// [`Unit`]()s like "kilometres per hour" are not recognized as "kilometres" but as themselves.
    ///
    /// Provides this Ordering for the
    /// [`BtreeMap`](https://doc.rust-lang.org/nightly/std/collections/struct.BTreeMap.html) in
    /// [`ChatSettings`](struct.ChatSettings.html).
    fn cmp(&self, other: &Self) -> Ordering {
        let self_max_count = self
            .long_hands
            .iter()
            .map(|s| s.split_whitespace())
            .map(|split| split.count())
            .max()
            .unwrap_or(0);
        let other_max_count = other
            .long_hands
            .iter()
            .map(|s| s.split_whitespace())
            .map(|split| split.count())
            .max()
            .unwrap_or(0);
        match other_max_count.cmp(&self_max_count) {
            Ordering::Less => Ordering::Less,
            Ordering::Equal => self.short_hand.cmp(&other.short_hand),
            Ordering::Greater => Ordering::Greater,
        }
    }
}

impl PartialOrd for Unit {
    /// Identical to implementation of
    /// [`Ord`](https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html), providing a complete
    /// order, as necessitated by `BTree`
    /// [collections](https://doc.rust-lang.org/std/collections/index.html).
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl fmt::Display for Unit {
    /// A display function for the case that we ever want to display [`Unit`]().
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.short_hand)
    }
}

/// A struct to hold instanced settings for each chat the bot is in.
///
/// Each instance represents the settings of a specific chat, which allows for the creation of
/// commands that personalize these settings, adding units, changing conversion rates, changing
/// which [`Unit`](struct.Unit.html)s
/// map to which target [`Unit`](struct.Unit.html)s, and so on.
///
/// # Example
/// ```
/// use auto_convert_bot::{ChatSettings, AutoConvertBot};
/// use telegram_bot::{Integer, ChatId};
///
/// let mut bot = AutoConvertBot::bot_setup();
/// // faking having received a new chat.
/// let chat_id = &ChatId::new(3);
///
/// let default_settings = ChatSettings::default();
/// bot.chat_map.insert(chat_id.clone(), default_settings);
/// assert_eq!(bot.chat_map.get(chat_id), Some(&ChatSettings::default()));
/// ```
#[derive(Clone, Debug)]
pub struct ChatSettings {
    // whether messages are returned in full, or only the converted units defaults to false.
    whole_message_always: bool,
    // the dictionary mapping units to their conversion target with a conversion rate.
    dictionary: BTreeMap<Unit, (Unit, f64)>,
    // a Set to hold all created units for this chat, referenced for Units during `/add_conversion`
    unit_set: HashSet<Unit>,
}

impl PartialEq for ChatSettings {
    /// [`PartialEq`](https://doc.rust-lang.org/core/cmp/trait.PartialEq.html) required for testing.
    fn eq(&self, other: &Self) -> bool {
        self.whole_message_always.eq(&other.whole_message_always)
            && self.unit_set == other.unit_set
            && self.dictionary == other.dictionary
    }
}

impl Default for ChatSettings {
    /// Constructs the default `ChatSettings`, used when registering a chat or on (planned)
    /// `/restore_defaults` command.
    ///
    /// Contains ugly hardcoded template to be replaced by a config in a later version.
    /// Config will be read in this same function, so no deprecation planned.
    /// Until such a time, this is where developers may add new units and conversion changes, either
    /// deploying their own version of the bot after Forking on Github, or getting their changes
    /// accepted in [`@auto_convert_bot`](https://t.me/auto_convert_bot) in a Pull Request.
    ///
    /// # Examples
    /// ```
    /// use auto_convert_bot::ChatSettings;
    /// let settings = ChatSettings::default();
    /// ```
    ///
    /// # panics
    /// if `unit_set` in this same function does not contain all [`Unit`](struct.Unit.html)s in
    /// `dictionary`, which would tests to fail, and thus never happens in production.
    fn default() -> Self {
        let unit_set: HashSet<Unit> = vec![
            Unit::new("pm", vec!["picometres".to_owned()]),
            Unit::new("nm", vec!["nanometres".to_owned()]),
            Unit::new("μm", vec!["micrometres".to_owned()]),
            Unit::new("mm", vec!["millimetres".to_owned()]),
            Unit::new("cm", vec!["centimetres".to_owned()]),
            Unit::new("dm", vec!["decimetres".to_owned()]),
            Unit::new("m", vec!["metres".to_owned()]),
            Unit::new("dam", vec!["decametres".to_owned()]),
            Unit::new("km", vec!["kilometres".to_owned()]),
            Unit::new("in", vec!["\"".to_owned(), "inches".to_owned()]),
            Unit::new("ft", vec!["\'".to_owned(), "feet".to_owned()]),
            Unit::new("yd", vec!["yards".to_owned()]),
            Unit::new("mi", vec!["miles".to_owned()]),
            Unit::new("wm", vec!["washingmachines".to_owned()]),
            Unit::new("pg", vec!["picograms".to_owned()]),
            Unit::new("ng", vec!["nanograms".to_owned()]),
            Unit::new("μg", vec!["micrograms".to_owned()]),
            Unit::new("mg", vec!["milligrams".to_owned()]),
            Unit::new("g", vec!["grams".to_owned()]),
            Unit::new("cg", vec!["centigrams".to_owned()]),
            Unit::new("dg", vec!["decigrams".to_owned()]),
            Unit::new("lb SI", vec!["metric pound".to_owned()]),
            Unit::new("kg", vec!["kilograms".to_owned()]),
            Unit::new("Mg", vec!["tonnes".to_owned()]),
            Unit::new("oz", vec!["ounces".to_owned()]),
            Unit::new("lb", vec!["pounds".to_owned()]),
            Unit::new("st", vec!["stone".to_owned()]),
            Unit::new("T", vec!["short tons".to_owned()]),
            Unit::new("tn", vec!["long tons".to_owned()]),
            Unit::new("°C", vec!["celsius".to_owned(), "Centigrade".to_owned()]),
            Unit::new("K", vec!["kelvin".to_owned()]),
            Unit::new("°F", vec!["fahrenheit".to_owned()]),
            Unit::new("°R", vec!["rankine".to_owned()]),
            Unit::new(
                "km/h",
                vec!["kilometres per hour".to_owned(), "kmh".to_owned()],
            ),
            Unit::new("mi/h", vec!["miles per hour".to_owned(), "mph".to_owned()]),
            Unit::new(
                "m/s",
                vec![
                    "metres per second".to_owned(),
                    "meters per second".to_owned(),
                    "ms¯¹".to_owned(),
                    "ms^-1".to_owned(),
                ],
            ),
            Unit::new(
                "ft/s",
                vec![
                    "feet per second".to_owned(),
                    "fps".to_owned(),
                    "fs¯¹".to_owned(),
                    "fs^-1".to_owned(),
                ],
            ),
            Unit::new("kn", vec!["knots".to_owned(), "kt".to_owned()]),
            Unit::new(
                "pm^2",
                vec![
                    "picometres squared".to_owned(),
                    "square picometres".to_owned(),
                    "pm²".to_owned(),
                    "sq pm".to_owned(),
                ],
            ),
            Unit::new(
                "nm^2",
                vec![
                    "nanometres squared".to_owned(),
                    "square nanometres".to_owned(),
                    "nm²".to_owned(),
                    "sq nm".to_owned(),
                ],
            ),
            Unit::new(
                "µm^2",
                vec![
                    "micrometres squared".to_owned(),
                    "square micrometres".to_owned(),
                    "µm²".to_owned(),
                    "sq µm".to_owned(),
                ],
            ),
            Unit::new(
                "mm^2",
                vec![
                    "millimetres squared".to_owned(),
                    "square millimetres".to_owned(),
                    "mm²".to_owned(),
                    "sq mm".to_owned(),
                ],
            ),
            Unit::new(
                "cm^2",
                vec![
                    "centimetres squared".to_owned(),
                    "square centimetres".to_owned(),
                    "cm²".to_owned(),
                    "sq cm".to_owned(),
                ],
            ),
            Unit::new(
                "dm^2",
                vec![
                    "decimetres squared".to_owned(),
                    "square decimetres".to_owned(),
                    "dm²".to_owned(),
                    "sq dm".to_owned(),
                ],
            ),
            Unit::new(
                "m^2",
                vec![
                    "metres squared".to_owned(),
                    "square metres".to_owned(),
                    "m²".to_owned(),
                    "sq m".to_owned(),
                ],
            ),
            Unit::new(
                "dam^2",
                vec![
                    "decametres squared".to_owned(),
                    "square decametres".to_owned(),
                    "dam²".to_owned(),
                    "sq dam".to_owned(),
                ],
            ),
            Unit::new("ha", vec!["hectare".to_owned()]),
            Unit::new(
                "km^2",
                vec![
                    "kilometres squared".to_owned(),
                    "square kilometres".to_owned(),
                    "km²".to_owned(),
                    "sq km".to_owned(),
                ],
            ),
            Unit::new(
                "in^2",
                vec![
                    "inches squared".to_owned(),
                    "square inches".to_owned(),
                    "in²".to_owned(),
                    "sq in".to_owned(),
                ],
            ),
            Unit::new(
                "ft^2",
                vec![
                    "feet squared".to_owned(),
                    "square foot".to_owned(),
                    "square feet".to_owned(),
                    "ft²".to_owned(),
                    "sq ft".to_owned(),
                ],
            ),
            Unit::new(
                "yd^2",
                vec![
                    "yards squared".to_owned(),
                    "square yards".to_owned(),
                    "yd²".to_owned(),
                    "sq yd".to_owned(),
                ],
            ),
            Unit::new(
                "mi^2",
                vec![
                    "miles squared".to_owned(),
                    "square miles".to_owned(),
                    "mi²".to_owned(),
                    "sq mi".to_owned(),
                ],
            ),
            Unit::new("ac", vec!["acres".to_owned(), "acre".to_owned()]),
            Unit::new(
                "pm^3",
                vec![
                    "picometres cubed".to_owned(),
                    "cubic picometres".to_owned(),
                    "pm³".to_owned(),
                    "cu pm".to_owned(),
                ],
            ),
            Unit::new(
                "nm^3",
                vec![
                    "nanometres cubed".to_owned(),
                    "cubic nanometres".to_owned(),
                    "nm³".to_owned(),
                    "cu nm".to_owned(),
                ],
            ),
            Unit::new(
                "µm^3",
                vec![
                    "micrometres cubed".to_owned(),
                    "cubic micrometres".to_owned(),
                    "µm³".to_owned(),
                    "cu µm".to_owned(),
                ],
            ),
            Unit::new(
                "mm^3",
                vec![
                    "millimetres cubed".to_owned(),
                    "cubic millimetres".to_owned(),
                    "mm³".to_owned(),
                    "cu mm".to_owned(),
                ],
            ),
            Unit::new(
                "cm^3",
                vec![
                    "centimetres cubed".to_owned(),
                    "cubic centimetres".to_owned(),
                    "cm³".to_owned(),
                    "cu cm".to_owned(),
                ],
            ),
            Unit::new(
                "dm^3",
                vec![
                    "decimetres cubed".to_owned(),
                    "cubic decimetres".to_owned(),
                    "dm³".to_owned(),
                    "cu dm".to_owned(),
                ],
            ),
            Unit::new(
                "m^3",
                vec![
                    "metres cubed".to_owned(),
                    "cubic metres".to_owned(),
                    "m³".to_owned(),
                    "cu m".to_owned(),
                ],
            ),
            Unit::new(
                "dam^3",
                vec![
                    "decametres cubed".to_owned(),
                    "cubic decametres".to_owned(),
                    "dam³".to_owned(),
                    "cu dam".to_owned(),
                ],
            ),
            Unit::new(
                "km^3",
                vec![
                    "kilometres cubed".to_owned(),
                    "cubic kilometres".to_owned(),
                    "km³".to_owned(),
                    "cu km".to_owned(),
                ],
            ),
            Unit::new(
                "in^3",
                vec![
                    "inches cubed".to_owned(),
                    "cubic inches".to_owned(),
                    "in³".to_owned(),
                    "cu in".to_owned(),
                ],
            ),
            Unit::new(
                "ft^3",
                vec![
                    "feet cubed".to_owned(),
                    "cubic foot".to_owned(),
                    "cubic feet".to_owned(),
                    "ft³".to_owned(),
                    "cu ft".to_owned(),
                ],
            ),
            Unit::new(
                "yd^3",
                vec![
                    "yards cubed".to_owned(),
                    "cubic yards".to_owned(),
                    "yd³".to_owned(),
                    "cu yd".to_owned(),
                ],
            ),
            Unit::new(
                "mi^3",
                vec![
                    "miles cubed".to_owned(),
                    "cubic miles".to_owned(),
                    "mi³".to_owned(),
                    "cu mi".to_owned(),
                ],
            ),
            Unit::new("ml", vec!["millilitres".to_owned()]),
            Unit::new("l", vec!["litres".to_owned()]),
            Unit::new("kl", vec!["kilolitres".to_owned()]),
            Unit::new(
                "tsp",
                vec!["teaspoons".to_owned(), "imperial teaspoons".to_owned()],
            ),
            Unit::new("ustsp", vec!["us teaspoons".to_owned()]),
            Unit::new(
                "tbsp",
                vec!["tablespoons".to_owned(), "imperial tablespoons".to_owned()],
            ),
            Unit::new("ustbsp", vec!["us tablespoons".to_owned()]),
            Unit::new(
                "fl oz",
                vec![
                    "fluid ounces".to_owned(),
                    "imperial fluid ounces".to_owned(),
                    "fl ounces".to_owned(),
                    "imperial fl ounces".to_owned(),
                    "oz. fl".to_owned(),
                    "imperial oz. fl".to_owned(),
                ],
            ),
            Unit::new(
                "usfl oz",
                vec![
                    "us fluid ounces".to_owned(),
                    "us fl ounces".to_owned(),
                    "us oz. fl".to_owned(),
                ],
            ),
            Unit::new("cup", vec!["cups".to_owned(), "imperial cups".to_owned()]),
            Unit::new("uscup", vec!["us cups".to_owned()]),
            Unit::new("p", vec!["pints".to_owned(), "imperial pints".to_owned()]),
            Unit::new("usp", vec!["us pints".to_owned()]),
            Unit::new(
                "gal",
                vec!["gallons".to_owned(), "imperial gallons".to_owned()],
            ),
            Unit::new("usgal", vec!["us gallons".to_owned()]),
            Unit::new("Pa", vec!["pascal".to_owned()]),
            Unit::new("psi", vec!["pounds per square inch".to_owned()]),
        ]
        .into_iter()
        .collect();

        let dictionary: BTreeMap<Unit, (Unit, f64)> = vec![
            (
                get_from_set("pm", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("in", &unit_set).expect("unit set and settings mismatch!"),
                    3.937007874015748e-11,
                ),
            ),
            (
                get_from_set("pm^2", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("in^2", &unit_set).expect("unit set and settings mismatch!"),
                    1.550003100006199e-21,
                ),
            ),
            (
                get_from_set("pm^3", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("in^3", &unit_set).expect("unit set and settings mismatch!"),
                    6.102374409473228e-32,
                ),
            ),
            (
                get_from_set("nm", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("in", &unit_set).expect("unit set and settings mismatch!"),
                    3.937007874015748e-08,
                ),
            ),
            (
                get_from_set("nm^2", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("in^2", &unit_set).expect("unit set and settings mismatch!"),
                    1.550003100006199e-15,
                ),
            ),
            (
                get_from_set("nm^3", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("in^3", &unit_set).expect("unit set and settings mismatch!"),
                    6.102374409473228e-23,
                ),
            ),
            (
                get_from_set("μm", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("in", &unit_set).expect("unit set and settings mismatch!"),
                    3.937007874015748e-05,
                ),
            ),
            (
                get_from_set("µm^2", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("in^2", &unit_set).expect("unit set and settings mismatch!"),
                    1.550003100006199e-9,
                ),
            ),
            (
                get_from_set("µm^3", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("in^3", &unit_set).expect("unit set and settings mismatch!"),
                    6.102374409473228e-14,
                ),
            ),
            (
                get_from_set("mm", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("in", &unit_set).expect("unit set and settings mismatch!"),
                    0.03937007874015748,
                ),
            ),
            (
                get_from_set("mm^2", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("in^2", &unit_set).expect("unit set and settings mismatch!"),
                    1.550003100006199e-3,
                ),
            ),
            (
                get_from_set("mm^3", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("in^3", &unit_set).expect("unit set and settings mismatch!"),
                    6.102374409473228e-5,
                ),
            ),
            (
                get_from_set("cm", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("in", &unit_set).expect("unit set and settings mismatch!"),
                    0.3937007874015748,
                ),
            ),
            (
                get_from_set("cm^2", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("in^2", &unit_set).expect("unit set and settings mismatch!"),
                    0.155000310000619999,
                ),
            ),
            (
                get_from_set("cm^3", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("in^3", &unit_set).expect("unit set and settings mismatch!"),
                    0.0610237440947322825,
                ),
            ),
            (
                get_from_set("dm", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("in", &unit_set).expect("unit set and settings mismatch!"),
                    3.937007874015748,
                ),
            ),
            (
                get_from_set("dm^2", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("in^2", &unit_set).expect("unit set and settings mismatch!"),
                    15.50003100006199987,
                ),
            ),
            (
                get_from_set("dm^3", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("in^3", &unit_set).expect("unit set and settings mismatch!"),
                    61.023744094732282488,
                ),
            ),
            (
                get_from_set("m", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("ft", &unit_set).expect("unit set and settings mismatch!"),
                    3.28083989501312300874,
                ),
            ),
            (
                get_from_set("m^2", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("ft^2", &unit_set).expect("unit set and settings mismatch!"),
                    10.76391041670972192890,
                ),
            ),
            (
                get_from_set("m^3", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("ft^3", &unit_set).expect("unit set and settings mismatch!"),
                    35.3146667214885789212,
                ),
            ),
            (
                get_from_set("m/s", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("ft/s", &unit_set).expect("unit set and settings mismatch!"),
                    3.28083989501312300874,
                ),
            ),
            (
                get_from_set("dam", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("yd", &unit_set).expect("unit set and settings mismatch!"),
                    10.93613298337707817609,
                ),
            ),
            (
                get_from_set("dam^2", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("yd^2", &unit_set).expect("unit set and settings mismatch!"),
                    119.59900463010802695862,
                ),
            ),
            (
                get_from_set("dam^3", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("yd^3", &unit_set).expect("unit set and settings mismatch!"),
                    1307.950619314392343020125,
                ),
            ),
            (
                get_from_set("km", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("mi", &unit_set).expect("unit set and settings mismatch!"),
                    0.62137119223733394691,
                ),
            ),
            (
                get_from_set("km^2", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("mi^2", &unit_set).expect("unit set and settings mismatch!"),
                    0.38610216008328374082,
                ),
            ),
            (
                get_from_set("km^3", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("mi^3", &unit_set).expect("unit set and settings mismatch!"),
                    0.23991275857892769037,
                ),
            ),
            (
                get_from_set("km/h", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("mi/h", &unit_set).expect("unit set and settings mismatch!"),
                    0.62137119223733394691,
                ),
            ),
            (
                get_from_set("ha", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("ac", &unit_set).expect("unit set and settings mismatch!"),
                    2.47105382834933307024,
                ),
            ),
            (
                get_from_set("in", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("cm", &unit_set).expect("unit set and settings mismatch!"),
                    2.54000000000000003553,
                ),
            ),
            (
                get_from_set("in^2", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("cm^2", &unit_set).expect("unit set and settings mismatch!"),
                    6.45159999999999911324,
                ),
            ),
            (
                get_from_set("in^3", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("cm^3", &unit_set).expect("unit set and settings mismatch!"),
                    16.38706399999999874240,
                ),
            ),
            (
                get_from_set("ft", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("m", &unit_set).expect("unit set and settings mismatch!"),
                    0.30480000000000001537,
                ),
            ),
            (
                get_from_set("ft^2", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("m^2", &unit_set).expect("unit set and settings mismatch!"),
                    0.09290304000000000617,
                ),
            ),
            (
                get_from_set("ft^3", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("m^3", &unit_set).expect("unit set and settings mismatch!"),
                    0.028316846592000004283,
                ),
            ),
            (
                get_from_set("ft/s", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("m/s", &unit_set).expect("unit set and settings mismatch!"),
                    0.3048,
                ),
            ),
            (
                get_from_set("yd", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("m", &unit_set).expect("unit set and settings mismatch!"),
                    0.91439999999999999059,
                ),
            ),
            (
                get_from_set("yd^2", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("m^2", &unit_set).expect("unit set and settings mismatch!"),
                    0.83612735999999998615,
                ),
            ),
            (
                get_from_set("yd^3", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("m^3", &unit_set).expect("unit set and settings mismatch!"),
                    0.76455485798399997639,
                ),
            ),
            (
                get_from_set("mi", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("km", &unit_set).expect("unit set and settings mismatch!"),
                    1.60934400000000010778,
                ),
            ),
            (
                get_from_set("mi^2", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("km^2", &unit_set).expect("unit set and settings mismatch!"),
                    2.58998810000000023734,
                ),
            ),
            (
                get_from_set("mi^3", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("km^3", &unit_set).expect("unit set and settings mismatch!"),
                    4.16818182544058042144,
                ),
            ),
            (
                get_from_set("mi/h", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("km/h", &unit_set).expect("unit set and settings mismatch!"),
                    1.60934400000000010778,
                ),
            ),
            (
                get_from_set("ac", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("ha", &unit_set).expect("unit set and settings mismatch!"),
                    0.40468564000000001313,
                ),
            ),
            (
                get_from_set("wm", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("in", &unit_set).expect("unit set and settings mismatch!"),
                    27.0,
                ),
            ),
            (
                get_from_set("kn", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("km/h", &unit_set).expect("unit set and settings mismatch!"),
                    1.85200000000000009059,
                ),
            ),
            (
                get_from_set("pg", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("oz", &unit_set).expect("unit set and settings mismatch!"),
                    0.00000000000003527396,
                ),
            ),
            (
                get_from_set("ng", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("oz", &unit_set).expect("unit set and settings mismatch!"),
                    0.00000000003527396211,
                ),
            ),
            (
                get_from_set("μg", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("oz", &unit_set).expect("unit set and settings mismatch!"),
                    0.00000003527396210511,
                ),
            ),
            (
                get_from_set("mg", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("oz", &unit_set).expect("unit set and settings mismatch!"),
                    0.00003527396210511196,
                ),
            ),
            (
                get_from_set("cg", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("oz", &unit_set).expect("unit set and settings mismatch!"),
                    0.00035273962105111959,
                ),
            ),
            (
                get_from_set("dg", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("oz", &unit_set).expect("unit set and settings mismatch!"),
                    0.00352739621051119598,
                ),
            ),
            (
                get_from_set("g", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("oz", &unit_set).expect("unit set and settings mismatch!"),
                    0.03527396210511195979,
                ),
            ),
            (
                get_from_set("lb SI", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("lb", &unit_set).expect("unit set and settings mismatch!"),
                    1.10231131092438783270,
                ),
            ),
            (
                get_from_set("kg", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("lb", &unit_set).expect("unit set and settings mismatch!"),
                    2.20462262184877566540,
                ),
            ),
            (
                get_from_set("Mg", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("tn", &unit_set).expect("unit set and settings mismatch!"),
                    0.98420653613529052173,
                ),
            ),
            (
                get_from_set("oz", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("g", &unit_set).expect("unit set and settings mismatch!"),
                    28.34952300000000491309,
                ),
            ),
            (
                get_from_set("lb", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("kg", &unit_set).expect("unit set and settings mismatch!"),
                    0.45359237000000002249,
                ),
            ),
            (
                get_from_set("st", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("kg", &unit_set).expect("unit set and settings mismatch!"),
                    6.35029317999999953770,
                ),
            ),
            (
                get_from_set("T", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("Mg", &unit_set).expect("unit set and settings mismatch!"),
                    0.90718474000000004498,
                ),
            ),
            (
                get_from_set("tn", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("Mg", &unit_set).expect("unit set and settings mismatch!"),
                    1.01604690000000008610,
                ),
            ),
            (
                get_from_set("°C", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("°F", &unit_set).expect("unit set and settings mismatch!"),
                    1.80000000000000004441,
                ),
            ),
            (
                get_from_set("°F", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("°C", &unit_set).expect("unit set and settings mismatch!"),
                    0.55555555555555558023,
                ),
            ),
            (
                get_from_set("K", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("°R", &unit_set).expect("unit set and settings mismatch!"),
                    1.80000000000000004441,
                ),
            ),
            (
                get_from_set("°R", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("K", &unit_set).expect("unit set and settings mismatch!"),
                    0.55555555555555558023,
                ),
            ),
            (
                get_from_set("ml", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("fl oz", &unit_set).expect("unit set and settings mismatch!"),
                    35.19508282458841108564,
                ),
            ),
            (
                get_from_set("l", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("gal", &unit_set).expect("unit set and settings mismatch!"),
                    0.21996924829908778842,
                ),
            ),
            (
                get_from_set("kl", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("gal", &unit_set).expect("unit set and settings mismatch!"),
                    219.96924829908778065146,
                ),
            ),
            (
                get_from_set("tsp", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("ml", &unit_set).expect("unit set and settings mismatch!"),
                    5.91939,
                ),
            ),
            (
                get_from_set("ustsp", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("ml", &unit_set).expect("unit set and settings mismatch!"),
                    4.93,
                ),
            ),
            (
                get_from_set("tbsp", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("ml", &unit_set).expect("unit set and settings mismatch!"),
                    17.7582,
                ),
            ),
            (
                get_from_set("ustbsp", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("ml", &unit_set).expect("unit set and settings mismatch!"),
                    14.8,
                ),
            ),
            (
                get_from_set("fl oz", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("ml", &unit_set).expect("unit set and settings mismatch!"),
                    28.41305999999999798433,
                ),
            ),
            (
                get_from_set("usfl oz", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("ml", &unit_set).expect("unit set and settings mismatch!"),
                    29.57353000000000520231,
                ),
            ),
            (
                get_from_set("cup", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("ml", &unit_set).expect("unit set and settings mismatch!"),
                    284.1305999999999798433,
                ),
            ),
            (
                get_from_set("uscup", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("ml", &unit_set).expect("unit set and settings mismatch!"),
                    236.59,
                ),
            ),
            (
                get_from_set("p", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("ml", &unit_set).expect("unit set and settings mismatch!"),
                    568.0,
                ),
            ),
            (
                get_from_set("usp", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("ml", &unit_set).expect("unit set and settings mismatch!"),
                    473.0,
                ),
            ),
            (
                get_from_set("gal", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("l", &unit_set).expect("unit set and settings mismatch!"),
                    4.55,
                ),
            ),
            (
                get_from_set("usgal", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("l", &unit_set).expect("unit set and settings mismatch!"),
                    3.78,
                ),
            ),
            (
                get_from_set("Pa", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("psi", &unit_set).expect("unit set and settings mismatch!"),
                    0.00014503774389728312,
                ),
            ),
            (
                get_from_set("psi", &unit_set).expect("unit set and settings mismatch!"),
                (
                    get_from_set("Pa", &unit_set).expect("unit set and settings mismatch!"),
                    6894.75699999999960709829,
                ),
            ),
        ]
        .into_iter()
        .collect();

        Self {
            whole_message_always: false,
            dictionary,
            unit_set,
        }
    }
}

impl ChatSettings {
    /// Constructor for [`ChatSettings`]().
    pub fn new(
        whole_message_always: bool,
        dictionary: BTreeMap<Unit, (Unit, f64)>,
        unit_set: HashSet<Unit>,
    ) -> Self {
        Self {
            whole_message_always,
            dictionary,
            unit_set,
        }
    }
}

/// Get an element from a
/// [`HashSet`](https://doc.rust-lang.org/nightly/std/collections/hash/set/struct.HashSet.html)`<`
/// [`Unit`](struct.Unit.html)`>` by short_hand.
fn get_from_set(short_hand: &str, set: &HashSet<Unit>) -> Option<Unit> {
    for names in set {
        if names.short_hand == short_hand {
            return Some(names.clone());
        }
    }
    None
}

#[cfg(test)]
mod tests {
    use crate::{ChatSettings, Unit};

    #[test]
    fn test_chat_settings_default() {
        // expect calls will cause test to fail on unit and settings mismatch.
        let _settings = ChatSettings::default();
    }
    #[test]
    fn test_unit() {
        let long_hands = vec![
            "long hand".to_owned(),
            "long_hand".to_owned(),
            "LongHand".to_owned(),
        ];
        let mut rev_hands = long_hands.clone();
        rev_hands.reverse();
        assert_eq!(Unit::new("", long_hands), Unit::new("", rev_hands))
    }
}
